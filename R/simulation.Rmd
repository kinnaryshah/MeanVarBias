```{r}
library(SpatialExperiment)
library(STexampleData)
library(MASS)
library(scuttle)

### GENERATING DATA

#4992 spots and 200 genes

n_genes <- 200
fraction <- 0.25
max_sigma.sq <- 10
low_range_beta <- c(1,10)
high_range_beta <- c(50,100)

#check if integer
stopifnot(n_genes*fraction*0.5 == round(n_genes*fraction*0.5))

  #150 genes will have sigma.sq = 0
  #50 genes will have sigma.sq randomly selected from a range 1 to 10 (this is ground truth of ranks)

sigma.sq <- rep(0,(1-fraction)*n_genes)
set.seed(123)
sigma.sq <- append(sigma.sq, runif(fraction*n_genes, 1, max_sigma.sq))

  #all genes will have nonzero beta values

  #150 genes will have exp(beta) values randomly selected from a range 1 to 100
  #25 of the 50 genes will have exp(beta) values randomly selected from a range 1 to 10
  #25 of the 50 genes will have exp(beta) values randomly selected from a range 50 to 100

set.seed(123)
beta <- runif((1-fraction)*n_genes, log(low_range_beta[1]), log(high_range_beta[2]))
set.seed(123)
beta <- append(beta, runif(n_genes*fraction*0.5, log(low_range_beta[1]), log(low_range_beta[2])))
beta <- append(beta, runif(n_genes*fraction*0.5, log(high_range_beta[1]), log(high_range_beta[2])))

#choose fixed length scale parameter (~medium from nnSVG paper)

scale_length <- 200

params <- data.frame(sigma.sq, beta)

#sampling from a poisson distribution - mean controls variance, so we don't specify tau.sq:
#step 1: use ST example distance matrix instead of creating a new one (Euclidean distance)

spe_demo <- Visium_humanDLPFC()
points_coord <- spatialCoords(spe_demo)
n_points <- nrow(points_coord)

pair.points <- cbind(
  matrix( rep(points_coord, each = n_points), ncol = 2, byrow = FALSE),
  rep(1, times = n_points) %x% points_coord # Creating the combinations using kronecker product.
) |> data.frame()
colnames(pair.points) <- c("si.x", "si.y", "sj.x", "sj.y")

#step 2: calculate gaussian process/kernel 

kernel.fun <- function(si.x, si.y, sj.x, sj.y,  l = 0.2){
  exp(-1*sqrt(((si.x-sj.x)^2+(si.y-sj.y)^2))/l)
}

C_theta <- with(pair.points, kernel.fun(si.x, si.y, sj.x, sj.y, l = scale_length)) |> 
  matrix(nrow = n_points, ncol = n_points)

counts <- matrix(NA, nrow = n_genes, ncol = n_points)

for (i in c(1:2)) {
  
  print(i)
  sigma.sq_i <- sigma.sq[i]
  beta_i <- beta[i]
  print(paste0(sigma.sq_i, " ", beta_i))
  
  #step 3: simulate gaussian process per gene
  
  set.seed(6)
  gp_dat <- mvrnorm(n = 1, rep(0,n_points), sigma.sq_i* C_theta) 

  #step 4: calculate lambda = exp(beta + gaussian process) per gene
  
  lambda_i <- exp(gp_dat + beta_i)
  
  #step 5: use rpois() to simulate 4992 values per gene

  counts_i <- rpois(n = n_points, lambda_i)
  
  #put all counts in matrix 
  #orientation: genes x spots
  
  counts[i,] <- counts_i
}

#create spe using counts and distance matrix

spe <- SpatialExperiment(
    assays = list(counts = counts),
    spatialCoords = points_coord)

spe <- logNormCounts(spe)

saveRDS(spe, spe_simulation.rds)

### USING THE DATA

#run nnSVG on the logcounts matrix

#run weighted nnSVG on the logcounts matrix

### EXPLORING CHANGING RANKS
#prop sv, sigma.sq, LR pre weighting, LR post weighting, etc.

```

